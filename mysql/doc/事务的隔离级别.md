## 事务的隔离级别

### 一、作用：事务隔离是来解决并发问题。

### 二、事务未隔离会带来哪些问题：

#### 1.脏读：一个事务读取到另一个事务未提交的数据。

如图有两个事务A,B

事务A修改了 id=1的数据，此时事务A还未提交事务。

事务B去读取 id=1的数据，发现数据已经被修改了。

事务A：

![1628667959283](assets\1628667959283.png)

事务B：

![1628668172237](assets\1628668172237.png)





#### 2.不可重复读：一个事务多次读取同一条数据，数据出现不一致的情况（一个未提交事务读取到另一个事务已提交修改的数据）



如图有两个事务A,B

事务A修改了 id=1的数据，此时事务A还未提交事务。事务B读取id=1的数据仍未修改。当事务A提交事务，此时事务B再去读取id=1的数据，发现数据已经被修改了。多次读取的数据发现不一致。

事务A：

![1628668995261](assets\1628668995261.png)



事务B：

![1628669195454](assets\1628669195454.png)



#### 3.幻读：一个事务读取到另一个事务已提交添加、删除的数据

如图有两个事务A,B

在事务B的期间，事务A新增了两条数据，此时事务B再次读取数据，发现新增了两条数据。

事务A：

![1628670824081](assets\1628670824081.png)



事务B：

![1628671057085](assets\1628671057085.png)



![1628671174237](assets\1628671174237.png)



### 三、事务的隔离：

#### 1.读未提交

脏读、不可重复读、幻读 都不能解决

![1628846593079](assets\1628846593079.png)

![1628846957293](assets\1628846957293.png)

小结：操作同一条数据时，会出现行锁。其它事务隔离级别同理。

#### 2.读已提交

脏读可解决，不可重复读、幻读不能解决

#### 3.可重复读

脏读、不可重复读可解决，幻读不能解决

#### 4.串行化

脏读、不可重复读、幻读可解决



### 四、oracle、mysql默认的隔离级别

oracle默认读已提交

mysql默认可重复读